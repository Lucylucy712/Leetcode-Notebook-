## 2.3 Class Definitions 

### 2.3.1 An example: CreditCard Class 

***A little self-understanding about the role of `self`***

Actually, we can take `self` as a container waiting for some customer information for each instance of the class. We need to know some characters firstly about the instance and then apply functions inside the class using those characters. Therefore, `self.xx` are a collection of different characters we need to assign or keep firstly. For each function in the class, we need to take `self` as the first parameter to give values needed for the function 


***Explanation of `self._name`***
We may find a lot of data members with a leading unserscore, e.g. `self._customer` in *Example CreditCard Class.py*. It implies that it's imtended as a ***nonpublic***. Users of a class should not directly access such members. 

As a general rule, we will treat all data members as nonpublic, which allows us to better enforce a consistent state for all instances. We can define somefunctions such as `get_customer` to provide a read-only access to those data. 


### 2.3.2 Operator Overloading and Python's Special Methods 

Check *2.3 Example Multidimensional Vector Class *. 

***What is Operator Overloading***

Operator are used to perform operations on variables and values. The most famous are including `+,-,/,*,%,//,+=`. However, one operator may means different operations when they are dealing with different data type. For example, `1+2 = 3` and `"a"+"b" = "ab"`. Therefore, we need to provide a definition of one operator when we define a class. It's called *Operator Overloading*. 

Typically, Python refers to the class of the left operand and covert the method call from the class. 

`+: __and__ ---> 2.__add__(3)`: Python check the left operand `(2)` class (int) and find how to operate `+` in the int class. 

`+: __and__ ---> 3.__add__("love")`: It would raise an TypeError since Python use operator `+` applicable for int class and it doesn't support between int and str. 

**There are a lot of overloaded operations, check them online or page 75 on the book**


***What is Non-Operator Overloads***

We can understand it now easily. Pythhon relies on specially named methods to control the behavior of various other functionality, when applies to user-defined classes. Similiar Technology to Opeartor Overloading, but for the non-operator functions. 

`str(123)--> 123.__str__()`
`bool(123)---> 123.__bool__()`
`len("abc")---> "abc"__len__()`


***Notes***
if a particular special method is not implemented in a user-defined class, the standard syntax that relies upon that method will raise an exception. For example, the expression `a+b` for instances of a user-defined class without `__add__` will raise an error. 


### 

